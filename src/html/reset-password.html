<html>
  <head>
    <title>重设密码</title>
    <link rel="bookmark" type="image/x-icon" href="https://raddeana-materials.oss-cn-hangzhou.aliyuncs.com/images/logo.png" />
    <link rel="shortcut icon" href="https://raddeana-materials.oss-cn-hangzhou.aliyuncs.com/images/logo.png">
    <link href="https://raddeana-libs.oss-cn-hangzhou.aliyuncs.com/pace/pace-theme-flash.min.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="https://raddeana-libs.oss-cn-hangzhou.aliyuncs.com/extra/normalize.css" />
    <script type="text/javascript" src="https://raddeana-libs.oss-cn-hangzhou.aliyuncs.com/pace/pace.min.js"></script>
    <link rel="stylesheet" href="https://raddeana-libs.oss-cn-hangzhou.aliyuncs.com/jquery/jquery.toast.min.css">
    <style type="text/css">
        body {
            background: #03121f;
        }

        .panel {
            display: none;
        }
  </style>
  </head>
  <body>
    <div class="panel">
        <h4 class="panel-title">修改密码</h4>
        <div class="panel-input-wrapper">
            <input
                id="password"
                class="input-text"
                placeholder="请输入新密码"
                type="password"
            />
        </div>
        <div class="panel-input-wrapper">
            <input
                id="repassword"
                class="input-text"
                placeholder="请重复密码"
                type="password"
            />
        </div>
        <div class="buttons-container">
            <button id="login" class="button-primary">登陆</button>
        </div>
    </div>
    <script type="text/javascript" src="https://raddeana-libs.oss-cn-hangzhou.aliyuncs.com/jquery/jquery-3.3.1.min.js"></script>
    <script type="text/javascript" src="https://raddeana-libs.oss-cn-hangzhou.aliyuncs.com/jquery/jquery.toast.min.js"></script>
    <script type="text/javascript" src="https://raddeana-libs.oss-cn-hangzhou.aliyuncs.com/threejs/stopExecutionOnTimeout.js"></script>
    <canvas id="webgl"></canvas>
    <script id="vertexShader" type="x-shader/x-vertex">
      attribute vec4 a_position;
      
      uniform mat4 u_modelViewMatrix;
      uniform mat4 u_projectionMatrix;
      
      void main () {
        gl_Position = a_position;
      }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;
        precision highp int;
      
        uniform vec2 u_resolution;
        uniform vec2 u_mouse;
        uniform float u_time;
        uniform sampler2D u_noise;
      
        // movement variables
        vec3 movement = vec3(.0);
      
        const int maxIterations = 64;
        const float stopThreshold = 0.001;
        const float stepScale = .7;
        const float eps = 0.005;
        const vec3 clipColour = vec3(0.);
        const vec3 fogColour = vec3(0.);
        
        const vec3 light1_position = vec3(0, 1., -1.);
        const vec3 light1_colour = vec3(.5, .8, 1.85);
        
        const int octaves = 3;
      
        struct Surface {
            int object_id;
            float distance;
            vec3 position;
            vec3 colour;
            float ambient;
            float spec;
        };
      
        float bumps (in vec3 p, float phase, float size, vec3 frequency) {
            return size * sin(p.x * frequency.x + phase) * cos(p.y * frequency.y + phase) * cos(p.z * frequency.z + phase);
        }
      
        float fractalBumps (in vec3 p, float phase, float size, vec3 frequency, float multiplier) {
            // const float octaves = 2.;
            float _bumps = bumps(p, phase, size, frequency);
            for(int i = 1; i < octaves; i++) {
                float f = float(i);
                _bumps += bumps(p, phase + f * 10., size * multiplier * 1./f, frequency * f);
            }

            return _bumps;
        }
      
        // This function describes the world in distances from any given 3 dimensional point in space
        float world (in vec3 position, inout int object_id) {
            vec3 pos = floor(position * .5);
            object_id = int(floor(pos.x + pos.y + pos.z));
            // position = mod(position, 1.) - .5;
            float gradient = max(0., (position.y + .3));
            float bumps = fractalBumps(position, u_time * 2., .5 * gradient, vec3(10. + sin(u_time) * 5.), 2.8);

            float world = length(position) - .4 + bumps * .15;

            // world = max(world, -position.y);

            return world;
        }

        float world(in vec3 position) {
            int dummy = 0;
            return world(position, dummy);
        }
      
        Surface getSurface (int object_id, float rayDepth, vec3 sp) {
            return Surface(object_id, rayDepth, sp, vec3(1.), .5, 200.);
        }
      
        // The raymarch loop
        Surface rayMarch (vec3 ro, vec3 rd, float start, float end, inout vec3 col, inout float steps) {
            float sceneDist = 1e4;
            float rayDepth = start;
            int object_id = 0;
            
            // Light position
            vec3 lp = ro + vec3(2, 2, -5.);
            
            bool hit = false;
            
            for(int i = 0; i < maxIterations; i++) {
            vec3 r = ro + rd * rayDepth;
            sceneDist = world(r, object_id);
            /*
            if(i==0) {
                rayDepth=sceneDist*.5;
                continue;
                }*/
            
            vec3 normal = normalize(r);
            vec3 ld = lp - r;
            float len = length( ld );
            ld = normalize(ld);
            float diffuse = max(0., dot(normal, ld))+.2;
            // diffuse*=diffuse;
            
            float weighting = length(r);
            
            col += clamp((1./abs(sceneDist))*weighting*diffuse*.004*light1_colour*step(-sceneDist, vec3(.0, 0.3, .02)), 0.0, 1.);
            
            if(sceneDist < stopThreshold) {
                rayDepth += .03;
            } else {
                rayDepth += sceneDist * (.1 / sceneDist);
            }
            
            if(rayDepth > end) {
                break;
            }
            steps += 1.;
            }
            
            return getSurface(object_id, rayDepth, ro + rd * rayDepth);
        }
    
        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x);
            
            // Camera and look-at
            vec3 cam = vec3(cos(u_mouse.x * 5.)*3.,u_mouse.y * 3.,sin(u_mouse.x * 5.)*3.);
            vec3 lookAt = vec3(0,0,0);
            
            // Unit vectors
            vec3 forward = normalize(lookAt - cam);
            vec3 right = normalize(vec3(forward.z, 0., -forward.x));
            vec3 up = normalize(cross(forward, right));
            
            // FOV
            float FOV = .4;
            
            // Ray origin and ray direction
            vec3 ro = cam;
            vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);
            
            // Ray marching
            const float clipNear = 0.;
            const float clipFar = 32.;
            vec3 col = vec3(0.);
            float steps = 0.;
            Surface objectSurface = rayMarch(ro, rd, clipNear, clipFar, col, steps);
            
            gl_FragColor = vec4(col, 1.);
            // gl_FragColor = vec4(vec3(steps*.001), 1.);
        }
    </script>
    <script type="text/javascript">
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        } ();

        function _classCallCheck(instance, Constructor) {
            if (! (instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        var WTCGL = function() {
            function WTCGL(el, vertexShaderSource, fragmentShaderSource, width, height, pxratio, styleElement) {
                _classCallCheck(this, WTCGL);
                this.run = this.run.bind(this);

                // If the HTML element isn't a canvas, return null
                if (!el instanceof HTMLElement || el.nodeName.toLowerCase() !== 'canvas') {
                    console.log('Provided element should be a canvas element');
                    return null;
                }

                this._el = el;
                // The context should be either webgl2, webgl or experimental-webgl
                this._ctx = this._el.getContext("webgl2", this.webgl_params) || this._el.getContext("webgl", this.webgl_params) || this._el.getContext("experimental-webgl", this.webgl_params);

                // Set up the extensions
                this._ctx.getExtension('OES_standard_derivatives');
                this._ctx.getExtension('EXT_shader_texture_lod');

                // We can't make the context so return an error
                if (!this._ctx) {
                    console.log('Browser doesn\'t support WebGL ');
                    return null;
                }

                // Create the shaders
                this._vertexShader = WTCGL.createShaderOfType(this._ctx, this._ctx.VERTEX_SHADER, vertexShaderSource);
                this._fragmentShader = WTCGL.createShaderOfType(this._ctx, this._ctx.FRAGMENT_SHADER, fragmentShaderSource);

                // Create the program and link the shaders
                this._program = this._ctx.createProgram();
                this._ctx.attachShader(this._program, this._vertexShader);
                this._ctx.attachShader(this._program, this._fragmentShader);
                this._ctx.linkProgram(this._program);

                // If we can't set up the params, this means the shaders have failed for some reason
                if (!this._ctx.getProgramParameter(this._program, this._ctx.LINK_STATUS)) {
                    console.log('Unable to initialize the shader program: ' + this._ctx.getProgramInfoLog(this._program));
                    return null;
                }

                // Initialise the vertex buffers
                this.initBuffers([ - 1.0, 1.0, -1., 1.0, 1.0, -1., -1.0, -1.0, -1., 1.0, -1.0, -1.]);
                this._programInfo = {
                    attribs: {
                        vertexPosition: this._ctx.getAttribLocation(this._program, 'a_position')
                    },

                    uniforms: {
                        projectionMatrix: this._ctx.getUniformLocation(this._program, 'u_projectionMatrix'),
                        modelViewMatrix: this._ctx.getUniformLocation(this._program, 'u_modelViewMatrix'),
                        resolution: this._ctx.getUniformLocation(this._program, 'u_resolution'),
                        time: this._ctx.getUniformLocation(this._program, 'u_time')
                    }
                };

                this._ctx.useProgram(this._program);
                this.pxratio = pxratio;
                this.styleElement = styleElement !== true;
                this.resize(width, height);
            }
            _createClass(WTCGL, [{
                key: 'resize',
                value: function resize(w, h) {
                    this._el.width = w * this.pxratio;
                    this._el.height = h * this.pxratio;
                    this._size = [w * this.pxratio, h * this.pxratio];
                    if (this.styleElement) {
                        this._el.style.width = w + 'px';
                        this._el.style.height = h + 'px';
                    }

                    this._ctx.viewportWidth = w * this.pxratio;
                    this._ctx.viewportHeight = h * this.pxratio;

                    this._ctx.uniform2fv(this._programInfo.uniforms.resolution, this._size);

                    this.initBuffers(this._positions);
                }
            },
            {
                key: 'initBuffers',
                value: function initBuffers(positions) {
                    this._positions = positions;
                    this._positionBuffer = this._ctx.createBuffer();

                    this._ctx.bindBuffer(this._ctx.ARRAY_BUFFER, this._positionBuffer);

                    this._ctx.bufferData(this._ctx.ARRAY_BUFFER, new Float32Array(positions), this._ctx.STATIC_DRAW);
                }
            },
            {
                key: 'addUniform',
                value: function addUniform(name, type, value) {
                    var uniform = this._programInfo.uniforms[name];
                    uniform = this._ctx.getUniformLocation(this._program, 'u_' + name);
                    switch (type) {
                    case WTCGL.TYPE_FLOAT:
                        if (!isNaN(value)) this._ctx.uniform1f(uniform, value);
                        break;
                    case WTCGL.TYPE_V2:
                        if (value instanceof Array && value.length === 2.) this._ctx.uniform2fv(uniform, value);
                        break;
                    case WTCGL.TYPE_V3:
                        if (value instanceof Array && value.length === 3.) this._ctx.uniform3fv(uniform, value);
                        break;
                    case WTCGL.TYPE_V4:
                        if (value instanceof Array && value.length === 4.) this._ctx.uniform4fv(uniform, value);
                        break;
                    }

                    this._programInfo.uniforms[name] = uniform;
                    return uniform;
                }
            },
            {
                key: 'updateTexture',
                value: function updateTexture(texture, image) {
                    this._ctx.bindTexture(this._ctx.TEXTURE_2D, texture);
                    this._ctx.texImage2D(this._ctx.TEXTURE_2D, 0, this._ctx.RGBA, this._ctx.RGBA, this._ctx.UNSIGNED_BYTE, image);
                }
            },
            {
                key: 'initTextures',
                value: function initTextures() {
                    for (var i = 0; i < this.textures.length; i++) {
                        if (window.CP.shouldStopExecution(0)) break;
                        var name = this.textures[i].name;
                        var uniform = this._programInfo.uniforms[name];

                        uniform = this._ctx.getUniformLocation(this._program, 'u_' + name);

                        this._ctx.uniform1i(uniform, i);
                        this._ctx.activeTexture(this._ctx['TEXTURE' + i]);
                        this._ctx.bindTexture(this._ctx.TEXTURE_2D, this.textures[i].tex);
                    }

                    window.CP.exitedLoop(0);
                }
            },
            {
                key: 'run',
                value: function run(delta) {
                    this.running && requestAnimationFrame(this.run);
                    this.time = this.startTime + delta * .0002;
                    this.render();
                }
            },
            {
                key: 'render',
                value: function render() {
                    var _this = this;
                    // Update the time uniform
                    this._ctx.uniform1f(this._programInfo.uniforms.time, this.time);

                    this._ctx.viewport(0, 0, this._ctx.viewportWidth, this._ctx.viewportHeight);
                    if (this.clearing) {
                        this._ctx.clearColor(1.0, 0.0, 0.0, 0.0);
                        this._ctx.clearDepth(1.0);
                        this._ctx.enable(this._ctx.DEPTH_TEST);
                        this._ctx.depthFunc(this._ctx.LEQUAL);
                        this._ctx.blendFunc(this._ctx.SRC_ALPHA, this._ctx.ONE_MINUS_SRC_ALPHA);

                        this._ctx.clear(this._ctx.COLOR_BUFFER_BIT);
                    }

                    this._ctx.bindBuffer(this._ctx.ARRAY_BUFFER, this._positionBuffer);
                    this._ctx.vertexAttribPointer(this._programInfo.attribs.vertexPosition, 3, this._ctx.FLOAT, false, 0, 0);
                    this._ctx.enableVertexAttribArray(this._programInfo.attribs.vertexPosition);

                    // Set the shader uniforms
                    this.includePerspectiveMatrix && this._ctx.uniformMatrix4fv(this._programInfo.uniforms.projectionMatrix, false, this.perspectiveMatrix);
                    this.includeModelViewMatrix && this._ctx.uniformMatrix4fv(this._programInfo.uniforms.modelViewMatrix, false, this.modelViewMatrix);

                    this._ctx.drawArrays(this._ctx.TRIANGLE_STRIP, 0, 4);
                }
            },
            {
                key: 'webgl_params',
                get: function get() {
                    return {
                        alpha: true
                    };
                }
            },
            {
                key: 'styleElement',
                set: function set(value) {
                    this._styleElement = value === true;
                    if (this._styleElement === false && this._el) {
                        this._el.style.width = '';
                        this._el.style.height = '';
                    }
                },
                get: function get() {
                    return this._styleElement !== false;
                }
            },
            {
                key: 'startTime',
                set: function set(value) {
                    if (!isNaN(value)) {
                        this._startTime = value;
                    }
                },
                get: function get() {
                    return this._startTime || 0;
                }
            },
            {
                key: 'time',
                set: function set(value) {
                    if (!isNaN(value)) {
                        this._time = value;
                    }
                },
                get: function get() {
                    return this._time || 0;
                }
            },
            {
                key: 'includePerspectiveMatrix',
                set: function set(value) {
                    this._includePerspectiveMatrix = value === true;
                },
                get: function get() {
                    return this._includePerspectiveMatrix === true;
                }
            },
            {
                key: 'includeModelViewMatrix',
                set: function set(value) {
                    this._includeModelViewMatrix = value === true;
                },
                get: function get() {
                    return this._includeModelViewMatrix === true;
                }
            },
            {
                key: 'clearing',
                set: function set(value) {
                    this._clearing = value === true;
                },
                get: function get() {
                    return this._clearing === true;
                }
            },
            {
                key: 'running',
                set: function set(value) { ! this.running && value === true && requestAnimationFrame(this.run);
                    this._running = value === true;
                },
                get: function get() {
                    return this._running === true;
                }
            },
            {
                key: 'pxratio',
                set: function set(value) {
                    if (value > 0) this._pxratio = value;
                },
                get: function get() {
                    return this._pxratio || 1;
                }
            },
            {
                key: 'perspectiveMatrix',
                get: function get() {
                    var fieldOfView = 45 * Math.PI / 180; // in radians
                    var aspect = this._size.w / this._size.h;
                    var zNear = 0.1;
                    var zFar = 100.0;
                    var projectionMatrix = mat4.create();
                    // note: glmatrix.js always has the first argument
                    // as the destination to receive the result.
                    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

                    return projectionMatrix;
                }
            },
            {
                key: 'modelViewMatrix',
                get: function get() {
                    // Set the drawing position to the "identity" point, which is
                    // the center of the scene.
                    var modelViewMatrix = mat4.create();

                    // Now move the drawing position a bit to where we want to
                    // start drawing the square.
                    mat4.translate(modelViewMatrix, // destination matrix
                    modelViewMatrix, // matrix to translate
                    [ - 0.0, 0.0, -1.]); // amount to translate
                    return modelViewMatrix;
                }
            }], [{
                key: 'createShaderOfType',
                value: function createShaderOfType(ctx, type, source) {
                    var shader = ctx.createShader(type);
                    ctx.shaderSource(shader, source);
                    ctx.compileShader(shader);

                    if (!ctx.getShaderParameter(shader, ctx.COMPILE_STATUS)) {
                        console.log('An error occurred compiling the shaders: ' + ctx.getShaderInfoLog(shader));
                        ctx.deleteShader(shader);
                        return null;
                    }

                    return shader;
                }
            }]);
            return WTCGL;
        } ();

        WTCGL.TYPE_INT = 0;
        WTCGL.TYPE_FLOAT = 1;
        WTCGL.TYPE_V2 = 2;
        WTCGL.TYPE_V3 = 3;
        WTCGL.TYPE_V4 = 4;

        WTCGL.IMAGETYPE_REGULAR = 0;
        WTCGL.IMAGETYPE_TILE = 1;
        WTCGL.IMAGETYPE_MIRROR = 2;
    </script>
    <script type="text/javascript">
        var twodWebGL = new WTCGL(
            document.querySelector('canvas#webgl'), 
            document.querySelector('script#vertexShader').textContent, 
            document.querySelector('script#fragmentShader').textContent, 
            window.innerWidth, 
            window.innerHeight, 
            2,
        );

        window.addEventListener('resize', function() {
            twodWebGL.resize(window.innerWidth, window.innerHeight);
        });

        twodWebGL.initTextures();
        twodWebGL.running = true;
    </script>
  </body>
</html>
